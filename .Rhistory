## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
mat = matrix(c(1,2,3,5), byrow = T)
mat
mat = matrix(c(1,2,3,5), byrow = T, nrow = 2)
mat
cacheSolve(mat)
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
makeCache(mat)
makeCacheMatrix(mat)
m2 = makeCacheMatrix(mat)
cacheSolve(m2)
cacheSolve(m2)
Mat = matrix(c(1,2,3,5), byrow = T, nrow = 2)
CachedMat = makeCacheMatrix(Mat) #Caching Data
cacheSolve(Mat) #First Computation
cacheSolve(Mat) #Second Computation gives the cached data
Mat = matrix(c(1,2,3,5), byrow = T, nrow = 2)
CachedMat = makeCacheMatrix(Mat) #Caching Data
cacheSolve(CacheMat) #First Computation
cacheSolve(CacheMat) #Second Computation gives the cached data
Mat = matrix(c(1,2,3,5), byrow = T, nrow = 2)
CachedMat = makeCacheMatrix(Mat) #Caching Data
cacheSolve(CachedMat) #First Computation
cacheSolve(CachedMat) #Second Computation gives the cached data
Mat
class(cacheSolve)
Mat * cacheSolve(CachedMat)
Mat * cacheSolve(CachedMat(CachedMat))
class(cacheSolve(CachedMat))
Mat*Mat
Mat*inv(Mat)
?matrix
Mat %*% cacheSolve(CachedMat)
